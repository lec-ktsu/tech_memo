# BM25Retriever の使い方 その 1
2025.09.14

## BM25について
BM25（Best Matching 25）は、情報検索（IR: Information Retrieval）や自然言語処理（NLP）で使われる 単語の重要度（スコア）を評価するアルゴリズム です。特に検索エンジンでクエリ（検索語）と文書の関連度を測るために使われます。</br>

### BM25とは？

BM25は、確率的な情報検索モデルである「Okapi BM25」に基づく手法です。TF-IDFの改良版と考えるとわかりやすいです。
BM25は、以下のような条件を考慮してクエリと文書の関連度を評価します：

- 単語の頻度（TF）：文書にその単語がどれだけ含まれているか。
- 逆文書頻度（IDF）：その単語がコレクション全体でどれだけ珍しいか。
- 文書の長さの補正：文書が長すぎてもスコアが不当に高くならないように調整。

### BM25のスコア計算式

BM25スコアは、クエリ中の各単語 `𝑞` に対して次式で計算されます：
$$
score(Q, D) = \sum_{q \in Q} IDF(q) \cdot \frac{f(q,D)\cdot (k_1 + 1)}{f(q,D)+k_1\cdot (1-b+b\cdot\frac{|D|}{avgdl})}
$$
ここで、`$Q$`は検索クエリ、`$D$`は文書、`$f(q,D)$`は単語$q$の文書$D$中の出現回数、`$|D|$`は文書$D$の長さ、`$avgdl$`はコレクション内の文書の平均長、`$k_1$`はTFスケーリングパラメータ（典型的には 1.2 ～ 2.0）、`$b$`は文書長の正規化パラメータ（通常 0.75）、`$IDF(q)$`は逆文書頻度（単語の珍しさを表す）である。

### IDF の計算
IDF も通常の TF-IDF とは違い、BM25 では次式で計算されます。
$$
IDF(q) = log\left(\frac{N - n(q) + 0.5}{n(q) + 0.5} + 1\right)
$$
ここで、$N$は文書全体の数、$n(q)$は単語$q$を含む文書の数を表す。

### BM25 の特徴と利点
| 特徴           | 説明                                      |
| ------------ | --------------------------------------- |
| TF-IDFより高精度  | 長さ補正や頻度スケーリングがあるため、より現実的                |
| 高速かつ効率的      | Lucene（Elasticsearch）など多くのIRエンジンで使われている |
| ハイパーパラメータ調整可 | $k_1$, $b$ により柔軟な調整が可能                  |



## 必要なモジュール
`BM25Retriever` は内部で `rank_bm25` パッケージを使っている。
インストールしていなければ、以下のコマンドでインストールする。
```python
pip install rank_bm25
```

## 検証に用いたモジュールのバージョン

|モジュール名|バージョン|
|--|--|
|langchain-core|0.3.75|
|langchain-community|0.3.29|
|langchain|0.3.27|
|python|3.12.9|

`BM25Retriever` は `langchain_community.retrievers.bm25` モジュールにある。
つまり、次のようにインポートする。
```python
from langchain_community.retrievers import BM25Retriever
from langchain_core.documents import Document
from langchain.text_splitter import CharacterTextSplitter
```

検索対象のドキュメントを準備する。
```python
# サンプルドキュメントの作成
docs = [
    Document(page_content="Pythonは人気の高いプログラミング言語です。", meta_data="プログラミング言語", tag="プログラミング言語"),
    Document(page_content="東京は日本の首都であり、経済の中心地です。", meta_data="日本", tag=["東京", "経済", "首都"]),
    Document(page_content="寿司は日本の代表的な料理の一つです。", meta_data="日本", tag=["寿司", "料理"]),
    Document(page_content="富士山は日本一高い山です。", meta_data="日本", tag=["富士山", "山"]),
]

# テキストを分割（BM25はBag-of-Wordsなので、適切に分割するのが良い）
text_splitter = CharacterTextSplitter(chunk_size=50, chunk_overlap=0)
split_docs = text_splitter.split_documents(docs)
print(type(split_docs), type(split_docs[0]))
print(split_docs[0])
```

BM25Retrieverを初期化する。
```python
retriever = BM25Retriever.from_documents(split_docs, k=3)
```

検索対象の文書に対してキーワード検索する。
```python
query = "日本の山"
results = retriever.invoke(query, meta_data="日本")
```

結果を表示する。
```python
print(f"🔍 クエリ: {query}")
print("📄 検索結果:")
for i, doc in enumerate(results):
    print(f"{i+1}. {doc.page_content}")
```


最後にコードをすべて記載しておく。
```python
from langchain_community.retrievers import BM25Retriever
from langchain_core.documents import Document
from langchain.text_splitter import CharacterTextSplitter

# 1. サンプルドキュメントの作成
docs = [
    Document(page_content="Pythonは人気の高いプログラミング言語です。", meta_data="プログラミング言語", tag="プログラミング言語"),
    Document(page_content="東京は日本の首都であり、経済の中心地です。", meta_data="日本", tag=["東京", "経済", "首都"]),
    Document(page_content="寿司は日本の代表的な料理の一つです。", meta_data="日本", tag=["寿司", "料理"]),
    Document(page_content="富士山は日本一高い山です。", meta_data="日本", tag=["富士山", "山"]),
]

# 2. テキストを分割（BM25はBag-of-Wordsなので、適切に分割するのが良い）
text_splitter = CharacterTextSplitter(chunk_size=50, chunk_overlap=0)
split_docs = text_splitter.split_documents(docs)
print(type(split_docs), type(split_docs[0]))
print(split_docs[0])

# 3. BM25Retriever の初期化
retriever = BM25Retriever.from_documents(split_docs, k=3)

# 4. 検索クエリを使って関連ドキュメントを検索
query = "日本の山"
results = retriever.invoke(query, meta_data="日本")

# 5. 結果の表示
print(f"🔍 クエリ: {query}")
print("📄 検索結果:")
for i, doc in enumerate(results):
    print(f"{i+1}. {doc.page_content}")
```

[ホームへ](../index.html)
[BM25retrieverの使い方 その 2](./bm25_02.html)