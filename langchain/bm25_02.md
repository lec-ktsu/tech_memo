# BM25Retriever の使い方 その 2
2025.09.14

検索結果とともにスコアを計算可能なクラス`ScoredBM25Retriever`を作成する。
`ScoredBM25Retriever` は LangChain の `BaseRetriever` を継承している。<br>
[BaseRetriever](https://python.langchain.com/api_reference/core/retrievers/langchain_core.retrievers.BaseRetriever.html)

LangChain v0.3 では、`BaseRetriever` は Pydantic v2 ベースになっているため、
フィールドを事前に宣言しておく必要がある。
具体的には、以下の 2 つが必要となる：

1. documents や k を `__init__` ではなく Pydantic フィールドとして宣言する
2. カスタムの `__init__` も極力使わず、`__post_init__` 相当の処理を `__init__` 後に行うように設計する


## 検証に用いたモジュールのバージョン

|モジュール名|バージョン|
|--|--|
|langchain-core|0.3.75|
|rank-bm25|0.2.2|
|pydantic|2.11.7|
|python|3.12.9|


## クラスの定義
`BaseRetriever`を継承する。
`Document` のリスト `documents` と検索結果の数 `k` を `Field` により指定しておく。</br>
※ `model_config` の詳細調査は T.B.D.
```python
class ScoredBM25Retriever(BaseRetriever):
    documents: List[Document] = Field()
    k: int = Field(default=4)

    # 明示的に許可
    model_config = {
        "arbitrary_types_allowed": True,
        "extra": "allow",
    }
```

## クラス変数の初期化
検索スコア計算のため、`BM25Okapi` オブジェクトを作成する。これは、`str` のリストで初期化する。
```python
def __init__(self, **data):
    super().__init__(**data)

    # __init__ 後に必要な初期化
    self.corpus = [list(doc.page_content) for doc in self.documents]
    self.bm25 = BM25Okapi(self.corpus)
```

## スコア付き検索関数の実装
ここでは、検索クエリは 1 文字ずつバラバラにしただけの単純なトークン化を用いた。
`bm25.get_scores(クエリ)` を実行することで、検索対象の文書に対してスコアを計算できる。
得られたスコアを用いて文書をソートし、上位から `k` 個の `Document` をリストに格納して返す。
この時、`metadata` に `score` の値を追加している。
```python
def _get_relevant_documents(self, query: str) -> List[Document]:
    tokenized_query = list(query)
    scores = self.bm25.get_scores(tokenized_query)

    # スコア付きでソート
    scored_docs = sorted(zip(self.documents, scores), key=lambda x: x[1], reverse=True)

    # 上位k件を返す（スコア付き）
    top_docs = []
    for doc, score in scored_docs[:self.k]:
        new_metadata = dict(doc.metadata)
        new_metadata["score"] = score
        top_docs.append(Document(page_content=doc.page_content, metadata=new_metadata))

    return top_docs
```

## 検索の実行用関数
上で定義した `__get_relevant_documetns` 関数を呼ぶよう `invoke` 関数は上書きする。
```python
def invoke(self, query: str) -> List[Document]:
    return self._get_relevant_documents(query)
```

## サンプルドキュメントの準備
`BM25Retriever` の時と同様に、`Document`のリストを準備する。
```python
from langchain_core.documents import Document

docs = [
    Document(page_content="Pythonは人気の高いプログラミング言語です。", metadata={"id": 1}),
    Document(page_content="東京は日本の首都であり、経済の中心地です。", metadata={"id": 2}),
    Document(page_content="寿司は日本の代表的な料理の一つです。", metadata={"id": 3}),
    Document(page_content="富士山は日本一高い山です。", metadata={"id": 4}),
]
```

## 検索の実行と結果の表示
検索は `BM25Retriever` 同様、`invoke`関数で行う。
検索結果の `score` のメタデータにアクセスすることで、検索スコアを表示できる。
```python
retriever = ScoredBM25Retriever(documents=docs, k=4)
query = "日本の山"
results = retriever.invoke(query)

print(f"🔍 クエリ: {query}")
print("📄 検索結果（スコア付き）:")
for i, doc in enumerate(results):
    print(f"{i+1}. score={doc.metadata['score']:.4f} | {doc.page_content}")
```


最後に完成したコードを載せておく。
```python
from langchain_core.documents import Document
from langchain_core.retrievers import BaseRetriever
from rank_bm25 import BM25Okapi
from typing import List
from pydantic import Field


class ScoredBM25Retriever(BaseRetriever):
    documents: List[Document] = Field()
    k: int = Field(default=4)

    # 明示的に許可
    model_config = {
        "arbitrary_types_allowed": True,
        "extra": "allow",
    }

    def __init__(self, **data):
        super().__init__(**data)

        # __init__ 後に必要な初期化
        self.corpus = [list(doc.page_content) for doc in self.documents]
        self.bm25 = BM25Okapi(self.corpus)

    def _get_relevant_documents(self, query: str) -> List[Document]:
        tokenized_query = list(query)
        scores = self.bm25.get_scores(tokenized_query)

        # スコア付きでソート
        scored_docs = sorted(zip(self.documents, scores), key=lambda x: x[1], reverse=True)

        # 上位k件を返す（スコア付き）
        top_docs = []
        for doc, score in scored_docs[:self.k]:
            new_metadata = dict(doc.metadata)
            new_metadata["score"] = score
            top_docs.append(Document(page_content=doc.page_content, metadata=new_metadata))

        return top_docs

    def invoke(self, query: str) -> List[Document]:
        return self._get_relevant_documents(query)


if __name__ == "__main__":
    from langchain_core.documents import Document

    docs = [
        Document(page_content="Pythonは人気の高いプログラミング言語です。", metadata={"id": 1}),
        Document(page_content="東京は日本の首都であり、経済の中心地です。", metadata={"id": 2}),
        Document(page_content="寿司は日本の代表的な料理の一つです。", metadata={"id": 3}),
        Document(page_content="富士山は日本一高い山です。", metadata={"id": 4}),
    ]

    retriever = ScoredBM25Retriever(documents=docs, k=4)
    query = "日本の山"
    results = retriever.invoke(query)

    print(f"🔍 クエリ: {query}")
    print("📄 検索結果（スコア付き）:")
    for i, doc in enumerate(results):
        print(f"{i+1}. score={doc.metadata['score']:.4f} | {doc.page_content}")
```

* まとめ

| 課題                                  | 解決策                                                          |
| ----------------------------------- | ------------------------------------------------------------ |
| LangChain の `BaseRetriever` 継承時のエラー | フィールドを `pydantic.Field()` で明示的に定義                            |
| `__init__` を使う場合の注意                 | `super().__init__(**data)` を必ず呼び出す                           |
| 非標準型（BM25Okapiなど）                   | `model_config = {"arbitrary_types_allowed": True}` を設定する必要あり |


[ホームへ](../index.html)
[BM25retrieverの使い方 その 1](./bm25_01.md)